---
title: Protobuf
description: Overview of protobuf, common use cases, and implementation details.
icon: chart-bar
---

Tilebox uses [Protocol Buffers](https://protobuf.dev/), with a custom generation tool, combined with standard Go data structures.

[Protocol Buffers](https://protobuf.dev/) (often refered to as `protobuf`) is the industry's most battle-tested schema definition language and it generates native Go bindings.
Protocol buffers are open-source since 2008 and are maintained by Google.

## tilebox-generate CLI

To generate Tilebox datasets type for Go, you will need to install the `tilebox-generate` CLI tool, see [Installation](/sdks/go/install) for more details.

```sh
tilebox-generate --dataset open_data.copernicus.sentinel1_sar
```

The command above will generate a `./protogen/tilebox/v1/sentinel1_sar.pb.go` file. More flags can be set to modify the default output folders, package name, etc.

This file contains everything needed to work with the [Sentinel-1 SAR](https://console.tilebox.com/datasets/explorer/e27e6a58-c149-4379-9fdf-9d43903cba74) dataset.
It is recommanded to check the generated files you use in your version control system.

If you open this file, you will see that it starts with `// Code generated by protoc-gen-go. DO NOT EDIT.`.
It means that the file was generated by the `protoc-gen-go` tool, which is part of the protobuf compiler.
After editing a dataset, you can call the generate command again to ensure that the changes are reflected in the generated file.

The file contains a `Sentinel1Sar` struct, which is a Go struct that represents a datapoint in the dataset.

```go Go
type Sentinel1Sar struct {
  xxx_hidden_GranuleName         *string                `protobuf:"bytes,1,opt,name=granule_name,json=granuleName"`
  xxx_hidden_ProcessingLevel     v1.ProcessingLevel     `protobuf:"varint,2,opt,name=processing_level,json=processingLevel,enum=datasets.v1.ProcessingLevel"`
  // more fields
}
```

Notice that the fields are private (starting with a lowercase letter), so they are not accessible.
The opaque API hides the fields and provides getters and setters to access them.

## Protobuf 101

Tilebox uses the recently released protobuf [Opaque API](https://go.dev/blog/protobuf-opaque), which provides multiple performance improvements over the OpenStruct API.

### Initializing a message

Here how to initialize a `tileboxv1.Sentinel1Sar` message.

```go Go
import (
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
)

datapoint := tileboxv1.Sentinel1Sar_builder{
	Time:        timestamppb.New(time.Now()),
	GranuleName: proto.String("S1A_EW_GRDH_1SSH_20141004T020507_20141004T020611_002673_002FAF_8645_COG.SAFE"),
	ProductType: proto.String("EW_GRDH_1S-COG"),
	FileSize:    proto.Int64(488383473),
}.Build()
```

The opaque API, as the name suggests, hides every fields of a message and provides a builder pattern to create a message.

Notice the usage of `proto.String` to convert `string` to `*string`.
This allows protobuf to differentiate between a field that is set to an empty string and a field that is not set (nil).
An exhaustive list of those helper functions can be found [here](https://github.com/golang/protobuf/blob/master/proto/wrappers.go).

Only primitives have a `proto.XXX` helper function. Complex types such as timestamps, durations, uuids and geometries have a constructor function.

```go Go
import (
	datasetsv1 "github.com/tilebox/tilebox-go/protogen/go/datasets/v1"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

timestamppb.New(time.Now())
durationpb.New(10 * time.Second)
datasetsv1.NewUUID(uuid.New())
```

### Getters and Setters

The protobuf Opaque API provides methods to get, set, clear and check if a field is set.

```go Go
fmt.Println(datapoint.GetGranuleName())

datapoint.SetGranuleName("my amazing granule")

datapoint.ClearGranuleName()

if datapoint.HasGranuleName() {
  fmt.Println("Granule name is set")
}
```

Getters for primitive types will return a Go native type (e.g. int64, string, bool, etc.).
Getters for complex types such as timestamps, durations, uuids and geometries can also be converted to a more user friendly type using `AsXXX` methods.

```go Go
datapoint.GetId().AsUUID() // uuid.UUID
datapoint.GetTime().AsTime() // time.Time
datapoint.GetDuration().AsDuration() // time.Duration
datapoint.GetGeometry().AsGeometry() // orb.Geometry
```

Those methods performs conversion on a best-effort basis. Type validity must be checked beforehand using `IsValid` or `CheckValid` methods.

## Common data operations

Datapoints are contained in a standard Go slice so all the usual [slice operations](https://gobyexample.com/slices) and [slice functions](https://pkg.go.dev/slices) can be used.

The usual pattern to iterate over data in Go is by using a `for` loop.

As an example, here is how to extract the `dayNightFlag` fields from the datapoints.

```go Go
// assuming datapoints has been filled using `client.Datapoints.LoadInto` method
var datapoints []*testv1.Modis

dayNightFlags := make([]string, len(datapoints))
for i, dp := range datapoints {
		dayNightFlags[i] = dp.GetDayNightFlag()
}
```

Here is an example of filtering out datapoints that have been published before January 2000 and have a `Night` value for `dayNightFlag`.

```go Go
jan2000 := time.Date(2000, time.January, 1, 0, 0, 0, 0, time.UTC)
// slice of length of 0, but preallocate a capacity of len(datapoints)
dayDatapoints := make([]*testv1.Modis, 0, len(datapoints))

for _, dp := range datapoints {
  if dp.GetPublishedAt().AsTime().Before(jan2000) {
    continue
  }
  if dp.GetDayNightFlag() == "Night" {
    continue
  }

  dayDatapoints = append(dayDatapoints, dp)
}
```

<Tip>
  `append` doesn't copy the underlying data, it only appends the pointer to the slice. To copy the data, use [proto.CloneOf](https://pkg.go.dev/google.golang.org/protobuf/proto#CloneOf).
</Tip>

## Converting to JSON

Protobuf messages can be converted to JSON without loss of information. This is useful for interoperability with other systems that doesn't use protobuf.
A guide on protoJSON format here: https://protobuf.dev/programming-guides/json/

```go Go
originalDatapoint := datapoints[2]

// Convert proto.Message to JSON as bytes
jsonDatapoint, err := protojson.Marshal(originalDatapoint)
if err != nil {
  log.Fatalf("Failed to marshal datapoint: %v", err)
}
fmt.Println(string(jsonDatapoint))
```

```plaintext Output
{"time":"2001-01-01T00:00:00Z","id":{"uuid":"AOPHpzQAAmV2MZ4+Zv+JGg=="},"ingestionTime":"2025-03-25T10:26:10.577385176Z","granuleName":"MCD12Q1.A2001001.h02v08.061.2022146033342.hdf","geometry":{"wkb":"AQMAAAABAAAABQAAAFIi9vf7TmTAXsX3////I0Bexff///9jwAAAAAAAAAAACUn4//+/YsAAAAAAAAAAAC7AdjgMCmPAXsX3////I0BSIvb3+05kwF7F9////yNA"},"endTime":"2001-12-31T23:59:59Z","horizontalTileNumber":"2","verticalTileNumber":"8","tileId":"51002008","fileSize":"176215","checksum":"771212892","checksumType":"CKSUM","dayNightFlag":"Day","publishedAt":"2022-06-23T10:58:13.895Z"}
```

It can also be converted back to a `proto.Message`.

```go Go
// Convert JSON bytes to proto.Message
unmarshalledDatapoint := &testv1.Modis{}
err = protojson.Unmarshal(jsonDatapoint, unmarshalledDatapoint)
if err != nil {
  log.Fatalf("Failed to unmarshal datapoint: %v", err)
}

fmt.Println("Are both equal?", proto.Equal(unmarshalledDatapoint, originalDatapoint))
```

```plaintext Output
Are both equal? true
```
